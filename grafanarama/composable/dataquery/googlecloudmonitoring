# generated by datamodel-codegen:
#   filename:  googlecloudmonitoringdataquery_types_gen.json
#   timestamp: 2024-03-23T05:20:31+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, List, Optional, Union

from pydantic import BaseModel, Field


class AlignmentTypes(Enum):
    ALIGN_DELTA = 'ALIGN_DELTA'
    ALIGN_RATE = 'ALIGN_RATE'
    ALIGN_INTERPOLATE = 'ALIGN_INTERPOLATE'
    ALIGN_NEXT_OLDER = 'ALIGN_NEXT_OLDER'
    ALIGN_MIN = 'ALIGN_MIN'
    ALIGN_MAX = 'ALIGN_MAX'
    ALIGN_MEAN = 'ALIGN_MEAN'
    ALIGN_COUNT = 'ALIGN_COUNT'
    ALIGN_SUM = 'ALIGN_SUM'
    ALIGN_STDDEV = 'ALIGN_STDDEV'
    ALIGN_COUNT_TRUE = 'ALIGN_COUNT_TRUE'
    ALIGN_COUNT_FALSE = 'ALIGN_COUNT_FALSE'
    ALIGN_FRACTION_TRUE = 'ALIGN_FRACTION_TRUE'
    ALIGN_PERCENTILE_99 = 'ALIGN_PERCENTILE_99'
    ALIGN_PERCENTILE_95 = 'ALIGN_PERCENTILE_95'
    ALIGN_PERCENTILE_50 = 'ALIGN_PERCENTILE_50'
    ALIGN_PERCENTILE_05 = 'ALIGN_PERCENTILE_05'
    ALIGN_PERCENT_CHANGE = 'ALIGN_PERCENT_CHANGE'
    ALIGN_NONE = 'ALIGN_NONE'


class DataQuery(BaseModel):
    refId: str = Field(
        ...,
        description='A unique identifier for the query within the list of targets.\nIn server side expressions, the refId is used as a variable name to identify results.\nBy default, the UI will assign A->Z; however setting meaningful names may be useful.',
    )
    hide: Optional[bool] = Field(
        None,
        description='true if query is disabled (ie should not be returned to the dashboard)\nNote this does not always imply that the query should not be executed since\nthe results from a hidden query may be used as the input to other queries (SSE etc)',
    )
    queryType: Optional[str] = Field(
        None,
        description='Specify the query flavor\nTODO make this required and give it a default',
    )
    datasource: Optional[Any] = Field(
        None,
        description="For mixed data sources the selected datasource is on the query level.\nFor non mixed scenarios this is undefined.\nTODO find a better way to do this ^ that's friendly to schema\nTODO this shouldn't be unknown but DataSourceRef | null",
    )


class Filter(BaseModel):
    key: str = Field(..., description='Filter key.')
    operator: str = Field(..., description='Filter operator.')
    value: str = Field(..., description='Filter value.')
    condition: Optional[str] = Field(None, description='Filter condition.')


class GoogleCloudMonitoringDataQuery(BaseModel):
    pass


class MetricFindQueryTypes(Enum):
    projects = 'projects'
    services = 'services'
    defaultProject = 'defaultProject'
    metricTypes = 'metricTypes'
    labelKeys = 'labelKeys'
    labelValues = 'labelValues'
    resourceTypes = 'resourceTypes'
    aggregations = 'aggregations'
    aligners = 'aligners'
    alignmentPeriods = 'alignmentPeriods'
    selectors = 'selectors'
    sloServices = 'sloServices'
    slo = 'slo'


class MetricKind(Enum):
    METRIC_KIND_UNSPECIFIED = 'METRIC_KIND_UNSPECIFIED'
    GAUGE = 'GAUGE'
    DELTA = 'DELTA'
    CUMULATIVE = 'CUMULATIVE'


class GraphPeriod(Enum):
    disabled = 'disabled'


class PreprocessorType(Enum):
    none = 'none'
    rate = 'rate'
    delta = 'delta'


class PromQLQuery(BaseModel):
    projectName: str = Field(
        ..., description='GCP project to execute the query against.'
    )
    expr: str = Field(..., description='PromQL expression/query to be executed.')
    step: str = Field(..., description='PromQL min step')


class QueryType(Enum):
    timeSeriesList = 'timeSeriesList'
    timeSeriesQuery = 'timeSeriesQuery'
    slo = 'slo'
    annotation = 'annotation'
    promQL = 'promQL'


class SLOQuery(BaseModel):
    projectName: str = Field(
        ..., description='GCP project to execute the query against.'
    )
    perSeriesAligner: Optional[str] = Field(
        None, description='Alignment function to be used. Defaults to ALIGN_MEAN.'
    )
    alignmentPeriod: Optional[str] = Field(
        None,
        description='Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.',
    )
    selectorName: str = Field(..., description='SLO selector.')
    serviceId: str = Field(..., description='ID for the service the SLO is in.')
    serviceName: str = Field(..., description='Name for the service the SLO is in.')
    sloId: str = Field(..., description='ID for the SLO.')
    sloName: str = Field(..., description='Name of the SLO.')
    goal: Optional[float] = Field(None, description='SLO goal value.')
    lookbackPeriod: Optional[str] = Field(
        None, description='Specific lookback period for the SLO.'
    )


class TimeSeriesList(BaseModel):
    projectName: str = Field(
        ..., description='GCP project to execute the query against.'
    )
    crossSeriesReducer: str = Field(
        ...,
        description='Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.',
    )
    alignmentPeriod: Optional[str] = Field(
        None,
        description='Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.',
    )
    perSeriesAligner: Optional[str] = Field(
        None, description='Alignment function to be used. Defaults to ALIGN_MEAN.'
    )
    groupBys: Optional[List[str]] = Field(
        None, description='Array of labels to group data by.'
    )
    filters: Optional[List[str]] = Field(
        None,
        description='Array of filters to query data by. Labels that can be filtered on are defined by the metric.',
    )
    view: Optional[str] = Field(None, description='Data view, defaults to FULL.')
    title: Optional[str] = Field(None, description='Annotation title.')
    text: Optional[str] = Field(None, description='Annotation text.')
    secondaryCrossSeriesReducer: Optional[str] = Field(
        None,
        description='Only present if a preprocessor is selected. Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.',
    )
    secondaryAlignmentPeriod: Optional[str] = Field(
        None,
        description='Only present if a preprocessor is selected. Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.',
    )
    secondaryPerSeriesAligner: Optional[str] = Field(
        None,
        description='Only present if a preprocessor is selected. Alignment function to be used. Defaults to ALIGN_MEAN.',
    )
    secondaryGroupBys: Optional[List[str]] = Field(
        None,
        description='Only present if a preprocessor is selected. Array of labels to group data by.',
    )
    preprocessor: Optional[PreprocessorType] = None


class TimeSeriesQuery(BaseModel):
    projectName: str = Field(
        ..., description='GCP project to execute the query against.'
    )
    query: str = Field(..., description='MQL query to be executed.')
    graphPeriod: Optional[Union[GraphPeriod, str]] = Field(
        None,
        description="To disable the graphPeriod, it should explictly be set to 'disabled'.",
    )


class ValueTypes(Enum):
    VALUE_TYPE_UNSPECIFIED = 'VALUE_TYPE_UNSPECIFIED'
    BOOL = 'BOOL'
    INT64 = 'INT64'
    DOUBLE = 'DOUBLE'
    STRING = 'STRING'
    DISTRIBUTION = 'DISTRIBUTION'
    MONEY = 'MONEY'


class CloudMonitoringQuery(DataQuery):
    aliasBy: Optional[str] = Field(
        None,
        description='Aliases can be set to modify the legend labels. e.g. {{metric.label.xxx}}. See docs for more detail.',
    )
    timeSeriesList: Optional[TimeSeriesList] = None
    timeSeriesQuery: Optional[TimeSeriesQuery] = None
    sloQuery: Optional[SLOQuery] = None
    promQLQuery: Optional[PromQLQuery] = None
    intervalMs: Optional[float] = Field(
        None, description='Time interval in milliseconds.'
    )


class LegacyCloudMonitoringAnnotationQuery(BaseModel):
    projectName: str = Field(
        ..., description='GCP project to execute the query against.'
    )
    metricType: str
    refId: str = Field(..., description='Query refId.')
    filters: List[str] = Field(
        ...,
        description='Array of filters to query data by. Labels that can be filtered on are defined by the metric.',
    )
    metricKind: MetricKind
    valueType: str
    title: str = Field(..., description='Annotation title.')
    text: str = Field(..., description='Annotation text.')


class MetricQuery(BaseModel):
    projectName: str = Field(
        ..., description='GCP project to execute the query against.'
    )
    perSeriesAligner: Optional[str] = Field(
        None, description='Alignment function to be used. Defaults to ALIGN_MEAN.'
    )
    alignmentPeriod: Optional[str] = Field(
        None,
        description='Alignment period to use when regularizing data. Defaults to cloud-monitoring-auto.',
    )
    aliasBy: Optional[str] = Field(
        None,
        description='Aliases can be set to modify the legend labels. e.g. {{metric.label.xxx}}. See docs for more detail.',
    )
    editorMode: str
    metricType: str
    crossSeriesReducer: str = Field(
        ...,
        description='Reducer applied across a set of time-series values. Defaults to REDUCE_NONE.',
    )
    groupBys: Optional[List[str]] = Field(
        None, description='Array of labels to group data by.'
    )
    filters: Optional[List[str]] = Field(
        None,
        description='Array of filters to query data by. Labels that can be filtered on are defined by the metric.',
    )
    metricKind: Optional[MetricKind] = None
    valueType: Optional[str] = None
    view: Optional[str] = None
    query: str = Field(..., description='MQL query to be executed.')
    preprocessor: Optional[PreprocessorType] = None
    graphPeriod: Optional[Union[GraphPeriod, str]] = Field(
        None,
        description="To disable the graphPeriod, it should explictly be set to 'disabled'.",
    )
