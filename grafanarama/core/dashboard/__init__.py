# generated by datamodel-codegen:
#   filename:  dashboard_types_gen.json
#   timestamp: 2024-03-23T05:19:27+00:00

from __future__ import annotations

from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import (
    AwareDatetime,
    BaseModel,
    Field,
    RootModel,
    confloat,
    conint,
    constr,
)

from . import status


class AnnotationPanelFilter(BaseModel):
    exclude: Optional[bool] = Field(
        False, description="Should the specified panels be included or excluded"
    )
    ids: List[conint(ge=0, le=255)] = Field(
        ..., description="Panel IDs that should be included or excluded"
    )


class AnnotationTarget(BaseModel):
    limit: int = Field(
        ...,
        description="Only required/valid for the grafana datasource...\nbut code+tests is already depending on it so hard to change",
    )
    matchAny: bool = Field(
        ...,
        description="Only required/valid for the grafana datasource...\nbut code+tests is already depending on it so hard to change",
    )
    tags: List[str] = Field(
        ...,
        description="Only required/valid for the grafana datasource...\nbut code+tests is already depending on it so hard to change",
    )
    type: str = Field(
        ...,
        description="Only required/valid for the grafana datasource...\nbut code+tests is already depending on it so hard to change",
    )


class DashboardCursorSync(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class DashboardLinkType(Enum):
    link = "link"
    dashboards = "dashboards"


class DataSourceRef(BaseModel):
    type: Optional[str] = Field(None, description="The plugin type-id")
    uid: Optional[str] = Field(None, description="Specific datasource instance")


class Topic(Enum):
    series = "series"
    annotations = "annotations"
    alertStates = "alertStates"


class DynamicConfigValue(BaseModel):
    id: str
    value: Optional[Any] = None


class FieldColorModeId(Enum):
    thresholds = "thresholds"
    palette_classic = "palette-classic"
    palette_classic_by_name = "palette-classic-by-name"
    continuous_GrYlRd = "continuous-GrYlRd"
    continuous_RdYlGr = "continuous-RdYlGr"
    continuous_BlYlRd = "continuous-BlYlRd"
    continuous_YlRd = "continuous-YlRd"
    continuous_BlPu = "continuous-BlPu"
    continuous_YlBl = "continuous-YlBl"
    continuous_blues = "continuous-blues"
    continuous_reds = "continuous-reds"
    continuous_greens = "continuous-greens"
    continuous_purples = "continuous-purples"
    fixed = "fixed"
    shades = "shades"


class FieldColorSeriesByMode(Enum):
    min = "min"
    max = "max"
    last = "last"


class GridPos(BaseModel):
    h: conint(le=4294967295, gt=0) = Field(
        ...,
        description="Panel height. The height is the number of rows from the top edge of the panel.",
    )
    w: conint(le=24, gt=0) = Field(
        ...,
        description="Panel width. The width is the number of columns from the left edge of the panel.",
    )
    x: conint(ge=0, lt=24) = Field(
        ...,
        description="Panel x. The x coordinate is the number of columns from the left edge of the grid",
    )
    y: conint(ge=0, le=4294967295) = Field(
        ...,
        description="Panel y. The y coordinate is the number of rows from the top edge of the grid",
    )
    static: Optional[bool] = Field(
        None,
        description="Whether the panel is fixed within the grid. If true, the panel will not be affected by other panels' interactions",
    )


class LibraryPanelRef(BaseModel):
    name: str = Field(..., description="Library panel name")
    uid: str = Field(..., description="Library panel uid")


class MappingType(Enum):
    value = "value"
    range = "range"
    regex = "regex"
    special = "special"


class MatcherConfig(BaseModel):
    id: str = Field(
        ...,
        description="The matcher id. This is used to find the matcher implementation from registry.",
    )
    options: Optional[Any] = Field(
        None,
        description="The matcher options. This is specific to the matcher implementation.",
    )


class RepeatDirection(Enum):
    h = "h"
    v = "v"


class Type(Enum):
    row = "row"


class Snapshot(BaseModel):
    created: AwareDatetime = Field(
        ..., description="Time when the snapshot was created"
    )
    expires: str = Field(
        ..., description="Time when the snapshot expires, default is never to expire"
    )
    external: bool = Field(
        ..., description="Is the snapshot saved in an external grafana instance"
    )
    externalUrl: str = Field(
        ...,
        description="external url, if snapshot was shared in external grafana instance",
    )
    originalUrl: str = Field(
        ..., description="original url, url of the dashboard that was snapshotted"
    )
    id: conint(ge=0, le=4294967295) = Field(
        ..., description="Unique identifier of the snapshot"
    )
    key: str = Field(
        ...,
        description="Optional, defined the unique key of the snapshot, required if external is true",
    )
    name: str = Field(..., description="Optional, name of the snapshot")
    orgId: conint(ge=0, le=4294967295) = Field(
        ..., description="org id of the snapshot"
    )
    updated: AwareDatetime = Field(
        ..., description="last time when the snapshot was updated"
    )
    url: Optional[str] = Field(
        None, description="url of the snapshot, if snapshot was shared internally"
    )
    userId: conint(ge=0, le=4294967295) = Field(
        ..., description="user id of the snapshot creator"
    )


class SpecialValueMatch(Enum):
    true = "true"
    false = "false"
    null = "null"
    nan = "nan"
    null_nan = "null+nan"
    empty = "empty"


class Target(BaseModel):
    pass


class Threshold(BaseModel):
    value: Optional[float] = Field(
        ...,
        description="Value represents a specified metric for the threshold, which triggers a visual change in the dashboard when this value is met or exceeded.\nNulls currently appear here when serializing -Infinity to JSON.",
    )
    color: str = Field(
        ...,
        description="Color represents the color of the visual change that will occur in the dashboard when the threshold value is met or exceeded.",
    )


class ThresholdsMode(Enum):
    absolute = "absolute"
    percentage = "percentage"


class TimePickerConfig(BaseModel):
    hidden: Optional[bool] = Field(
        False, description="Whether timepicker is visible or not."
    )
    refresh_intervals: Optional[List[str]] = Field(
        ["5s", "10s", "30s", "1m", "5m", "15m", "30m", "1h", "2h", "1d"],
        description="Interval options available in the refresh picker dropdown.",
    )
    time_options: Optional[List[str]] = Field(
        ["5m", "15m", "1h", "6h", "12h", "24h", "2d", "7d", "30d"],
        description="Selectable options available in the time picker dropdown. Has no effect on provisioned dashboard.",
    )
    nowDelay: Optional[str] = Field(
        None,
        description="Override the now time by entering a time delay. Use this option to accommodate known delays in data aggregation to avoid null values.",
    )


class ValueMappingResult(BaseModel):
    text: Optional[str] = Field(
        None, description="Text to display when the value matches"
    )
    color: Optional[str] = Field(None, description="Text to use when the value matches")
    icon: Optional[str] = Field(
        None,
        description="Icon to display when the value matches. Only specific visualizations.",
    )
    index: Optional[int] = Field(
        None, description="Position in the mapping array. Only used internally."
    )


class VariableHide(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class VariableOption(BaseModel):
    selected: Optional[bool] = Field(
        None, description="Whether the option is selected or not"
    )
    text: Union[str, List[str]] = Field(
        ..., description="Text to be displayed for the option"
    )
    value: Union[str, List[str]] = Field(..., description="Value of the option")


class VariableRefresh(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2


class VariableSort(Enum):
    integer_0 = 0
    integer_1 = 1
    integer_2 = 2
    integer_3 = 3
    integer_4 = 4
    integer_5 = 5
    integer_6 = 6
    integer_7 = 7
    integer_8 = 8


class VariableType(Enum):
    query = "query"
    adhoc = "adhoc"
    groupby = "groupby"
    constant = "constant"
    datasource = "datasource"
    interval = "interval"
    textbox = "textbox"
    custom = "custom"
    system = "system"


class FieldKubeObjectMetadata(BaseModel):
    uid: str
    creationTimestamp: AwareDatetime
    deletionTimestamp: Optional[AwareDatetime] = None
    finalizers: List[str]
    resourceVersion: str
    labels: Dict[str, str]


class Metadata(FieldKubeObjectMetadata):
    updateTimestamp: AwareDatetime
    createdBy: str
    updatedBy: str
    extraFields: Dict[str, Any] = Field(
        ...,
        description="extraFields is reserved for any fields that are pulled from the API server metadata but do not have concrete fields in the CUE metadata",
    )


class Time(BaseModel):
    from_: str = Field(..., alias="from")
    to: str


class AnnotationQuery(BaseModel):
    name: str = Field(..., description="Name of annotation.")
    datasource: DataSourceRef
    enable: bool = Field(
        ...,
        description="When enabled the annotation query is issued with every dashboard refresh",
    )
    hide: Optional[bool] = Field(
        False,
        description="Annotation queries can be toggled on or off at the top of the dashboard.\nWhen hide is true, the toggle is not shown in the dashboard.",
    )
    iconColor: str = Field(
        ..., description="Color to use for the annotation event markers"
    )
    filter: Optional[AnnotationPanelFilter] = None
    target: Optional[AnnotationTarget] = None
    type: Optional[str] = Field(
        None,
        description="TODO -- this should not exist here, it is based on the --grafana-- datasource",
    )
    builtIn: Optional[float] = Field(
        0,
        description="Set to 1 for the standard annotation query all dashboards have by default.",
    )


class DashboardLink(BaseModel):
    title: str = Field(..., description="Title to display with the link")
    type: DashboardLinkType
    icon: str = Field(..., description="Icon name to be displayed with the link")
    tooltip: str = Field(
        ..., description="Tooltip to display when the user hovers their mouse over it"
    )
    url: Optional[str] = Field(
        None, description="Link URL. Only required/valid if the type is link"
    )
    tags: List[str] = Field(
        ...,
        description="List of tags to limit the linked dashboards. If empty, all dashboards will be displayed. Only valid if the type is dashboards",
    )
    asDropdown: bool = Field(
        ...,
        description="If true, all dashboards links will be displayed in a dropdown. If false, all dashboards links will be displayed side by side. Only valid if the type is dashboards",
    )
    targetBlank: bool = Field(
        ..., description="If true, the link will be opened in a new tab"
    )
    includeVars: bool = Field(
        ...,
        description="If true, includes current template variables values in the link as query params",
    )
    keepTime: bool = Field(
        ...,
        description="If true, includes current time range in the link as query params",
    )


class DataTransformerConfig(BaseModel):
    id: str = Field(..., description="Unique identifier of transformer")
    disabled: Optional[bool] = Field(
        None, description="Disabled transformations are skipped"
    )
    filter: Optional[MatcherConfig] = None
    topic: Optional[Topic] = Field(
        None, description="Where to pull DataFrames from as input to transformation"
    )
    options: Any = Field(
        ...,
        description="Options to be passed to the transformer\nValid options depend on the transformer id",
    )


class FieldColor(BaseModel):
    mode: FieldColorModeId
    fixedColor: Optional[str] = Field(
        None, description="The fixed color value for fixed or shades color modes."
    )
    seriesBy: Optional[FieldColorSeriesByMode] = None


class Override(BaseModel):
    matcher: MatcherConfig
    properties: List[DynamicConfigValue]


class Options(BaseModel):
    from_: Optional[confloat(ge=-1.7976931348623157e308, le=1.7976931348623157e308)] = (
        Field(
            ...,
            alias="from",
            description="Min value of the range. It can be null which means -Infinity",
        )
    )
    to: Optional[confloat(ge=-1.7976931348623157e308, le=1.7976931348623157e308)] = (
        Field(
            ...,
            description="Max value of the range. It can be null which means +Infinity",
        )
    )
    result: ValueMappingResult


class RangeMap(BaseModel):
    type: MappingType
    options: Options = Field(
        ...,
        description="Range to match against and the result to apply when the value is within the range",
    )


class Options1(BaseModel):
    pattern: str = Field(..., description="Regular expression to match against")
    result: ValueMappingResult


class RegexMap(BaseModel):
    type: MappingType
    options: Options1 = Field(
        ...,
        description="Regular expression to match against and the result to apply when the value matches the regex",
    )


class Options2(BaseModel):
    match: SpecialValueMatch
    result: ValueMappingResult


class SpecialValueMap(BaseModel):
    type: MappingType
    options: Options2


class ThresholdsConfig(BaseModel):
    mode: ThresholdsMode
    steps: List[Threshold] = Field(
        ..., description="Must be sorted by 'value', first value is always -Infinity"
    )


class ValueMap(BaseModel):
    type: MappingType
    options: Dict[str, ValueMappingResult] = Field(
        ...,
        description='Map with <value_to_match>: ValueMappingResult. For example: { "10": { text: "Perfection!", color: "green" } }',
    )


class ValueMapping(RootModel[Union[ValueMap, RangeMap, RegexMap, SpecialValueMap]]):
    root: Union[ValueMap, RangeMap, RegexMap, SpecialValueMap] = Field(
        ...,
        description="Allow to transform the visual representation of specific data values in a visualization, irrespective of their original units",
    )


class VariableModel(BaseModel):
    type: VariableType
    name: str = Field(..., description="Name of variable")
    label: Optional[str] = Field(None, description="Optional display name")
    hide: Optional[VariableHide] = None
    skipUrlSync: Optional[bool] = Field(
        False,
        description="Whether the variable value should be managed by URL query params or not",
    )
    description: Optional[str] = Field(
        None, description="Description of variable. It can be defined but `null`."
    )
    query: Optional[Union[str, Dict[str, Any]]] = Field(
        None, description="Query used to fetch values for a variable"
    )
    datasource: Optional[DataSourceRef] = None
    current: Optional[VariableOption] = None
    multi: Optional[bool] = Field(
        False,
        description="Whether multiple values can be selected or not from variable value list",
    )
    options: Optional[List[VariableOption]] = Field(
        None, description="Options that can be selected for a variable."
    )
    refresh: Optional[VariableRefresh] = None
    sort: Optional[VariableSort] = None
    includeAll: Optional[bool] = Field(
        False, description="Whether all value option is available or not"
    )
    allValue: Optional[str] = Field(None, description="Custom all value")
    regex: Optional[str] = Field(
        None,
        description="Optional field, if you want to extract part of a series name or metric node segment.\nNamed capture groups can be used to separate the display text and value.",
    )


class Templating(BaseModel):
    list: Optional[List[VariableModel]] = Field(
        None,
        description="List of configured template variables with their saved values along with some other metadata",
    )


class Status(BaseModel):
    operatorStates: Optional[Dict[str, status.OperatorState]] = Field(
        None,
        description="operatorStates is a map of operator ID to operator state evaluations.\nAny operator which consumes this kind SHOULD add its state evaluation information to this field.",
    )
    additionalFields: Optional[Dict[str, Any]] = Field(
        None, description="additionalFields is reserved for future use"
    )


class AnnotationContainer(BaseModel):
    list: Optional[List[AnnotationQuery]] = Field(
        None, description="List of annotations"
    )


class FieldConfig(BaseModel):
    displayName: Optional[str] = Field(
        None,
        description="The display value for this field.  This supports template variables blank is auto",
    )
    displayNameFromDS: Optional[str] = Field(
        None,
        description="This can be used by data sources that return and explicit naming structure for values and labels\nWhen this property is configured, this value is used rather than the default naming strategy.",
    )
    description: Optional[str] = Field(
        None, description="Human readable field metadata"
    )
    path: Optional[str] = Field(
        None,
        description="An explicit path to the field in the datasource.  When the frame meta includes a path,\nThis will default to `${frame.meta.path}/${field.name}\n\nWhen defined, this value can be used as an identifier within the datasource scope, and\nmay be used to update the results",
    )
    writeable: Optional[bool] = Field(
        None,
        description="True if data source can write a value to the path. Auth/authz are supported separately",
    )
    filterable: Optional[bool] = Field(
        None, description="True if data source field supports ad-hoc filters"
    )
    unit: Optional[str] = Field(
        None,
        description="Unit a field should use. The unit you select is applied to all fields except time.\nYou can use the units ID availables in Grafana or a custom unit.\nAvailable units in Grafana: https://github.com/grafana/grafana/blob/main/packages/grafana-data/src/valueFormats/categories.ts\nAs custom unit, you can use the following formats:\n`suffix:<suffix>` for custom unit that should go after value.\n`prefix:<prefix>` for custom unit that should go before value.\n`time:<format>` For custom date time formats type for example `time:YYYY-MM-DD`.\n`si:<base scale><unit characters>` for custom SI units. For example: `si: mF`. This one is a bit more advanced as you can specify both a unit and the source data scale. So if your source data is represented as milli (thousands of) something prefix the unit with that SI scale character.\n`count:<unit>` for a custom count unit.\n`currency:<unit>` for custom a currency unit.",
    )
    decimals: Optional[float] = Field(
        None,
        description="Specify the number of decimals Grafana includes in the rendered value.\nIf you leave this field blank, Grafana automatically truncates the number of decimals based on the value.\nFor example 1.1234 will display as 1.12 and 100.456 will display as 100.\nTo display all decimals, set the unit to `String`.",
    )
    min: Optional[float] = Field(
        None,
        description="The minimum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.",
    )
    max: Optional[float] = Field(
        None,
        description="The maximum value used in percentage threshold calculations. Leave blank for auto calculation based on all series and fields.",
    )
    mappings: Optional[List[ValueMapping]] = Field(
        None, description="Convert input values into a display string"
    )
    thresholds: Optional[ThresholdsConfig] = None
    color: Optional[FieldColor] = None
    links: Optional[List] = Field(
        None, description="The behavior when clicking on a result"
    )
    noValue: Optional[str] = Field(None, description="Alternative to empty string")
    custom: Optional[Dict[str, Any]] = Field(
        None,
        description="custom is specified by the FieldConfig field\nin panel plugin schemas.",
    )


class FieldConfigSource(BaseModel):
    defaults: FieldConfig
    overrides: List[Override] = Field(
        ...,
        description="Overrides are the options applied to specific fields overriding the defaults.",
    )


class Panel(BaseModel):
    type: constr(min_length=1) = Field(
        ...,
        description="The panel plugin type id. This is used to find the plugin to display the panel.",
    )
    id: Optional[conint(ge=0, le=4294967295)] = Field(
        None,
        description="Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.",
    )
    pluginVersion: Optional[str] = Field(
        None,
        description="The version of the plugin that is used for this panel. This is used to find the plugin to display the panel and to migrate old panel configs.",
    )
    targets: Optional[List[Target]] = Field(
        None,
        description="Depends on the panel plugin. See the plugin documentation for details.",
    )
    title: Optional[str] = Field(None, description="Panel title.")
    description: Optional[str] = Field(None, description="Panel description.")
    transparent: Optional[bool] = Field(
        False, description="Whether to display the panel without a background."
    )
    datasource: Optional[DataSourceRef] = None
    gridPos: Optional[GridPos] = None
    links: Optional[List[DashboardLink]] = Field(None, description="Panel links.")
    repeat: Optional[str] = Field(
        None, description="Name of template variable to repeat for."
    )
    repeatDirection: Optional[RepeatDirection] = Field(
        "h",
        description="Direction to repeat in if 'repeat' is set.\n`h` for horizontal, `v` for vertical.",
    )
    maxPerRow: Optional[float] = Field(
        None,
        description="Option for repeated panels that controls max items per row\nOnly relevant for horizontally repeated panels",
    )
    maxDataPoints: Optional[float] = Field(
        None,
        description="The maximum number of data points that the panel queries are retrieving.",
    )
    transformations: Optional[List[DataTransformerConfig]] = Field(
        None,
        description="List of transformations that are applied to the panel data before rendering.\nWhen there are multiple transformations, Grafana applies them in the order they are listed.\nEach transformation creates a result set that then passes on to the next transformation in the processing pipeline.",
    )
    interval: Optional[str] = Field(
        None,
        description='The min time interval setting defines a lower limit for the $__interval and $__interval_ms variables.\nThis value must be formatted as a number followed by a valid time\nidentifier like: "40s", "3d", etc.\nSee: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options',
    )
    timeFrom: Optional[str] = Field(
        None,
        description="Overrides the relative time range for individual panels,\nwhich causes them to be different than what is selected in\nthe dashboard time picker in the top-right corner of the dashboard. You can use this to show metrics from different\ntime periods or days on the same dashboard.\nThe value is formatted as time operation like: `now-5m` (Last 5 minutes), `now/d` (the day so far),\n`now-5d/d`(Last 5 days), `now/w` (This week so far), `now-2y/y` (Last 2 years).\nNote: Panel time overrides have no effect when the dashboard’s time range is absolute.\nSee: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options",
    )
    timeShift: Optional[str] = Field(
        None,
        description="Overrides the time range for individual panels by shifting its start and end relative to the time picker.\nFor example, you can shift the time range for the panel to be two hours earlier than the dashboard time picker setting `2h`.\nNote: Panel time overrides have no effect when the dashboard’s time range is absolute.\nSee: https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/#query-options",
    )
    hideTimeOverride: Optional[bool] = Field(
        None,
        description="Controls if the timeFrom or timeShift overrides are shown in the panel header",
    )
    libraryPanel: Optional[LibraryPanelRef] = None
    cacheTimeout: Optional[str] = Field(
        None, description="Sets panel queries cache timeout."
    )
    queryCachingTTL: Optional[float] = Field(
        None,
        description="Overrides the data source configured time-to-live for a query cache item in milliseconds",
    )
    options: Optional[Dict[str, Any]] = Field(
        None,
        description="It depends on the panel plugin. They are specified by the Options field in panel plugin schemas.",
    )
    fieldConfig: Optional[FieldConfigSource] = None


class RowPanel(BaseModel):
    type: Type = Field(..., description="The panel type")
    collapsed: bool = Field(
        ..., description="Whether this row should be collapsed or not."
    )
    title: Optional[str] = Field(None, description="Row title")
    datasource: Optional[DataSourceRef] = None
    gridPos: Optional[GridPos] = None
    id: conint(ge=0, le=4294967295) = Field(
        ...,
        description="Unique identifier of the panel. Generated by Grafana when creating a new panel. It must be unique within a dashboard, but not globally.",
    )
    panels: List[Panel] = Field(..., description="List of panels in the row")
    repeat: Optional[str] = Field(
        None, description="Name of template variable to repeat for."
    )


class Spec(BaseModel):
    id: Optional[conint(ge=-9223372036854775808, le=9223372036854775807)] = Field(
        None,
        description="Unique numeric identifier for the dashboard.\n`id` is internal to a specific Grafana instance. `uid` should be used to identify a dashboard across Grafana instances.",
    )
    uid: Optional[str] = Field(
        None,
        description="Unique dashboard identifier that can be generated by anyone. string (8-40)",
    )
    title: Optional[str] = Field(None, description="Title of dashboard.")
    description: Optional[str] = Field(None, description="Description of dashboard.")
    revision: Optional[int] = Field(
        None,
        description="This property should only be used in dashboards defined by plugins.  It is a quick check\nto see if the version has changed since the last time.",
    )
    gnetId: Optional[str] = Field(
        None,
        description="ID of a dashboard imported from the https://grafana.com/grafana/dashboards/ portal",
    )
    tags: Optional[List[str]] = Field(
        None, description="Tags associated with dashboard."
    )
    timezone: Optional[str] = Field(
        "browser",
        description='Timezone of dashboard. Accepted values are IANA TZDB zone ID or "browser" or "utc".',
    )
    editable: Optional[bool] = Field(
        True, description="Whether a dashboard is editable or not."
    )
    graphTooltip: Optional[DashboardCursorSync] = 0
    time: Optional[Time] = Field(
        None,
        description="Time range for dashboard.\nAccepted values are relative time strings like {from: 'now-6h', to: 'now'} or absolute time strings like {from: '2020-07-10T08:00:00.000Z', to: '2020-07-10T14:00:00.000Z'}.",
    )
    timepicker: Optional[TimePickerConfig] = None
    fiscalYearStartMonth: Optional[conint(ge=0, lt=12)] = Field(
        0,
        description="The month that the fiscal year starts on.  0 = January, 11 = December",
    )
    liveNow: Optional[bool] = Field(
        None,
        description='When set to true, the dashboard will redraw panels at an interval matching the pixel width.\nThis will keep data "moving left" regardless of the query refresh rate. This setting helps\navoid dashboards presenting stale live data',
    )
    weekStart: Optional[str] = Field(
        None,
        description='Day when the week starts. Expressed by the name of the day in lowercase, e.g. "monday".',
    )
    refresh: Optional[str] = Field(
        None,
        description='Refresh rate of dashboard. Represented via interval string, e.g. "5s", "1m", "1h", "1d".',
    )
    schemaVersion: conint(ge=0, le=65535) = Field(
        ...,
        description="Version of the JSON schema, incremented each time a Grafana update brings\nchanges to said schema.",
    )
    version: Optional[conint(ge=0, le=4294967295)] = Field(
        None,
        description="Version of the dashboard, incremented each time the dashboard is updated.",
    )
    panels: Optional[List[Union[Panel, RowPanel]]] = Field(
        None, description="List of dashboard panels"
    )
    templating: Optional[Templating] = Field(
        None, description="Configured template variables"
    )
    annotations: Optional[AnnotationContainer] = None
    links: Optional[List[DashboardLink]] = Field(
        None,
        description="Links with references to other dashboards or external websites.",
    )
    snapshot: Optional[Snapshot] = None


class Dashboard(BaseModel):
    metadata: Metadata = Field(
        ...,
        description="metadata contains embedded CommonMetadata and can be extended with custom string fields\nTODO: use CommonMetadata instead of redefining here; currently needs to be defined here\nwithout external reference as using the CommonMetadata reference breaks thema codegen.",
    )
    spec: Spec
    status: Status
